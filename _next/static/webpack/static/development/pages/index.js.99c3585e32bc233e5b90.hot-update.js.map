{"version":3,"file":"static/webpack/static/development/pages/index.js.99c3585e32bc233e5b90.hot-update.js","sources":["webpack:///./src/react-marker.js"],"sourcesContent":["// @flow\n\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { useMap } from './google-map';\n\ntype MarkerProps = {|\n  lat: number,\n  lng: number,\n  children: React.Node,\n|};\n\nexport const Marker = (props: MarkerProps) => {\n  return props.children;\n};\n\ntype OverlayProps = {|\n  children?: React.ChildrenArray<null | boolean | React.Element<typeof Marker>>,\n  // Debug is used to center markers right\n  debug?: boolean,\n|};\n\nexport const Overlay = (props: OverlayProps) => {\n  const { api, mapa } = useMap();\n  // because I have 2 ;-), doesnt matter here, will be set before 1st usage\n  const pixelRatioRef = React.useRef(2);\n\n  // $FlowFixMe no block level $FlowFixMe so splitted on 2 lines\n  const anyChildren = (React.Children.toArray(props.children || []): any);\n\n  const children: $ReadOnlyArray<React.Element<typeof Marker>> = anyChildren;\n\n  const [overlay, setOverlay] = React.useState(null);\n\n  const childrenLatLngRefs = React.useRef<\n    Array<$NonMaybeType<{| lat: number, lng: number |}>>,\n  >([]);\n\n  const childrenDivRefs = React.useRef([]);\n\n  const subPixelRound = v =>\n    Math.round(v * pixelRatioRef.current) / pixelRatioRef.current;\n\n  // We can't use useEffect here because it causes glitches\n  // when in draw we update commited markers with previous markers coordinates\n  // it is visible if make a lot of zoomin zoomout, as map draw is fully independent of react\n  React.useLayoutEffect(() => {\n    childrenLatLngRefs.current = children.map(ch => ({\n      lat: ch.props.lat,\n      lng: ch.props.lng,\n    }));\n  });\n\n  // Create overlay https://developers.google.com/maps/documentation/javascript/examples/overlay-simple\n  React.useEffect(() => {\n    if (api) {\n      pixelRatioRef.current = window.devicePixelRatio;\n\n      const overlayView = new api.OverlayView();\n      let elt = null;\n\n      overlayView.onAdd = () => {\n        elt = document.createElement('div');\n        var panes = overlayView.getPanes();\n        // on all other panes there is issues with events like hover etc\n        panes.floatPane.appendChild(elt);\n\n        setOverlay({\n          element: elt,\n          view: overlayView,\n        });\n      };\n\n      overlayView.onRemove = () => {\n        if (elt != null) {\n          const { parentNode } = elt;\n          if (parentNode != null) {\n            // same as panes.overlayMouseTarget.removeChild\n            parentNode.removeChild(elt);\n          }\n          setOverlay(null);\n        }\n      };\n\n      overlayView.draw = () => {\n        var projection = overlayView.getProjection();\n\n        const latLngs = childrenLatLngRefs.current;\n\n        latLngs.forEach(({ lat, lng }, index) => {\n          const { current: childElt } = childrenDivRefs.current[index];\n          if (childElt != null) {\n            const pos = projection.fromLatLngToDivPixel(\n              new api.LatLng(lat, lng),\n            );\n            // Move react markers directly changing dom element position\n            // Element is created by us, not by library user, so no issues\n            childElt.style.left = subPixelRound(pos.x) + 'px';\n            childElt.style.top = subPixelRound(pos.y) + 'px';\n          }\n        });\n      };\n\n      overlayView.setMap(map);\n\n      return () => {\n        overlayView.setMap(null);\n      };\n    }\n  }, [api, map]);\n\n  if (overlay != null && children != null && api != null) {\n    const projection = overlay.view.getProjection();\n\n    return ReactDOM.createPortal(\n      children.map((ch, index) => {\n        const pos = projection.fromLatLngToDivPixel(\n          new api.LatLng(ch.props.lat, ch.props.lng),\n        );\n\n        // Its not a side effect, its just a cache for refs\n        // instead of creating it initially like Array(MAX_POSSIBLE_MARKERS), we just extend it here\n        if (childrenDivRefs.current[index] == null) {\n          childrenDivRefs.current[index] = { current: null };\n        }\n\n        return (\n          <div\n            key={ch.key}\n            ref={childrenDivRefs.current[index]}\n            style={{\n              position: 'absolute',\n              left: subPixelRound(pos.x),\n              top: subPixelRound(pos.y),\n              display: 'grid',\n              gridTemplate: '0/0',\n            }}\n          >\n            {ch}\n            {(process.env.NODE_ENV !== 'production' ||\n              process.env.DOCUMENTATION === 'true') &&\n              props.debug === true && (\n                <div\n                  style={{\n                    position: 'absolute',\n                    borderRadius: '100%',\n                    width: 4,\n                    height: 4,\n                    left: -2,\n                    top: -2,\n                    opacity: 0.8,\n                    boxShadow:\n                      '0 0 0 2px blue, 0 0 0 4px white, 0 0 0 6px blue',\n                  }}\n                />\n              )}\n          </div>\n        );\n      }),\n      overlay.element,\n    );\n  }\n  return null;\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;;AAQA;AACA;AACA;AAQA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AATA;AAAA;AAAA;AAAA;AACA;AAWA;AAIA;AACA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AADA;AACA;AAAA;AACA;AACA;AAFA;AAAA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAKA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AAGA;AACA;AAAA;AACA;;;;A","sourceRoot":""}